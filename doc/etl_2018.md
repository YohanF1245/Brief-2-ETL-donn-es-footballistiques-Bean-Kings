


# Documentation du nettoyage pour 2018

## 1. Aperçu des données (Source JSON)
Contrairement aux autres années (CSV), la source 2018 est un fichier JSON imbriqué (`data_2018.json`).
Il nécessite une étape préliminaire d'extraction relationnelle avant d'avoir un DataFrame.

### Structure brute
- **`stadiums`** : Liste de référence (ID -> Ville).
- **`teams`** : Liste de référence (ID -> Nom Pays, ISO, Drapeaux).
- **`groups`** : Dictionnaire contenant les matchs de poule (imbriqués).
- **`knockout`** : Dictionnaire contenant les phases finales (imbriqués).
- **`tvchannels`** : Ignoré (non pertinent pour l'analyse).

## 2. Stratégie d'Extraction (Flattening)
Nous ne pouvons pas charger le fichier directement. Nous utilisons des dictionnaires de correspondance ("Lookups") pour remplacer les IDs par des valeurs lisibles.

### Création des Lookups
```py
# On transforme les listes en dictionnaires pour un accès O(1)
teams_map = {t['id']: t['name'] for t in data['teams']}
# ex: {1: "Russia", 9: "France"}

stadiums_map = {s['id']: s['city'] for s in data['stadiums']}
# ex: {1: "Moscow"}
```

### Aplatissement de la structure
Nous bouclons sur les clés `groups` et `knockout` pour extraire chaque match et l'ajouter dans une liste unique.
```py
# Exemple de logique appliquée pour chaque match
match_clean = {
    'raw_date': m['date'],
    'raw_home_team': teams_map.get(m['home_team']), # Traduction ID -> Nom
    'raw_city': stadiums_map.get(m['stadium']),     # Traduction ID -> Ville
    # ...
}
```

## 3. Sécurisation et Nettoyage (Transformation)

### Fonctions utilitaires
Utilisation de `unidecode` pour standardiser le texte (suppression des accents).
```py
def clean_text_field(text):
    if pd.isna(text): return "unknown"
    return unidecode(str(text)).lower().strip()
```

### Date et Heure
Conversion du format timestamp complexe du JSON vers le format ISO standard.
```py
# Entrée : "2018-06-14T18:00:00+03:00"
# Sortie : "2018-06-14 15:00:00" (UTC)
df['Date'] = pd.to_datetime(df['raw_date'], utc=True).dt.strftime('%Y-%m-%d %H:%M:%S')
```

### Standardisation des étapes (Stage)
Harmonisation des noms pour correspondre au format du fichier 2014.
```py
def standardize_stage_name(val):
    val = clean_text_field(val)
    if 'group' in val: return 'group'
    if 'round of 16' in val: return 'round of 16'
    # ... (quarter, semi, final)
    return val
```

### Conversion des Buts
Conversion explicite en Entiers (`int`) et gestion des valeurs nulles.
```py
df['Home Team Goals'] = df['home_goals'].fillna(0).astype(int)
df['Away Team Goals'] = df['away_goals'].fillna(0).astype(int)
```

## 4. Détermination des Vainqueurs (Logique Métier)
Le JSON fournit le score, mais nous recalculons les résultats pour garantir la cohérence des colonnes `Home Result` et `Away Result` (winner, loser, draw).

### Comparaison des scores
Nous utilisons `np.select` pour vectoriser le calcul (plus rapide qu'une boucle).

```py
conditions = [
    (df['Home Team Goals'] > df['Away Team Goals']), # Cas 1 : Home gagne
    (df['Home Team Goals'] < df['Away Team Goals']), # Cas 2 : Away gagne
    (df['Home Team Goals'] == df['Away Team Goals']) # Cas 3 : Nul
]

choices_home = ['winner', 'loser', 'draw']
choices_away = ['loser', 'winner', 'draw']

df['Home Result'] = np.select(conditions, choices_home, default='draw')
df['Away Result'] = np.select(conditions, choices_away, default='draw')
```
*Note : Pour 2018, les tirs au but sont gérés implicitement par le score final ou considérés comme 'draw' dans le temps réglementaire selon la consigne simplifiée, mais le code est extensible.*

## 5. Schéma Final
Sélection et renommage des colonnes pour correspondre au schéma cible unique du projet.

```py
final_cols = [
    'Date', 
    'Stage', 
    'City', 
    'Home Team Name', 
    'Away Team Name', 
    'Home Team Goals', 
    'Away Team Goals', 
    'Home Result', 
    'Away Result'
]
df = df[final_cols]
```